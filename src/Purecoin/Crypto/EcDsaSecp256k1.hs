module Purecoin.Crypto.EcDsaSecp256k1
       ( PublicKey, PrivateKey, mkPubKey
       , Signature, verifySignature, unsafeMkSignature
       ) where

import Control.Applicative ((<$>), (<*>))
import Control.Monad (guard)
import Data.Maybe (fromMaybe)
import Data.Serialize ( Serialize, runPut
                      , get, getWord8, isolate
                      , put, putWord8, putByteString
                      )
import qualified Data.ByteString as BS
import Purecoin.Crypto.ZModule ((*+))
import Purecoin.Crypto.EcDsaSecp256k1.Point ( Point, mkPoint, isInfinity, getx, b
                                            , p, sqrtFp
                                            , Fn, scale, shamirsTrick
                                            , castFpToFn, uncastFnToFp)

-- a generator of the elliptic curve
g :: Point
Just g = mkPoint 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
                 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8

-- order of curve / order of group generated by g = cofactor
cofactor :: Integer
cofactor = 1

type PrivateKey = Fn
type PublicKey = Point

mkPubKey :: PrivateKey -> PublicKey
mkPubKey n = n `scale` g

data Signature = Signature Fn Fn deriving Show

-- DER serialization of Signatures
instance Serialize Signature where
  get = do 0x30 <- getWord8
           len <- getWord8
           guard (len <= 0x7f)
           isolate (fromIntegral len) (Signature <$> get <*> get)

  put (Signature r s) | len <= 0x7f = putWord8 0x30 >> putWord8 (fromIntegral len)
                                   >> putByteString content
                      | otherwise = error "Serialize Signature value too large"
    where
      len = BS.length content
      content = runPut $ put r >> put s

verifySignature :: PublicKey -> Integer -> Signature -> Bool
verifySignature _        _ (Signature 0 _) = False
verifySignature _        _ (Signature _ 0) = False
verifySignature pubKey hash (Signature r s) | isInfinity pubKey = False
                                            | otherwise = go p
  where
    u1, u2, invs :: Fn
    invs = recip s
    u1 = fromInteger hash * invs
    u2 = r * invs
    p = shamirsTrick u1 g u2 pubKey
    go p = fromMaybe False (do {xp <- getx p; return (castFpToFn xp == r)})

-- if you reuse a nonce, the your private key will be exposed!
-- returns Nothing when you give a 0 private key
-- returns Just Nothing when you need to try a difference nonce
unsafeMkSignature :: PrivateKey -> Integer -> Fn -> Maybe (Maybe Signature)
unsafeMkSignature 0 _ _ = Nothing
unsafeMkSignature privKey hash nonce = Just $ getx p >>= go . castFpToFn
  where
   p = nonce `scale` g
   go 0          = Nothing
   go r | s == 0 = Nothing
        | otherwise = Just (Signature r s)
     where
       s :: Fn
       s = (fromInteger hash + r*privKey)/nonce

keyRecovery :: Integer -> Signature -> [PublicKey]
keyRecovery hash (Signature r s) =
  do x <- uncastFnToFp r
     y <- sqrtFp (x^3 + {-a*x +-} b)
     p <- mkPoint x y
     let invr = recip r
     return $ shamirsTrick (invr * s) p
                           (invr * fromInteger (-hash)) g
